# 入门指南

## 什么是Form？

## 为什么需要Form？

- 现阶段大部分表单解决方案，主要解决的问题
  - 表单快速搭建
  - 领域的表达，关注配置化
- 现在阶段太关注表单的搭建而忽略字段之间的联动关系，在大型复杂关系的表单系统中，对配置化的诉求几乎为0（字段能力不好抽象，联动关系不好抽象），核心问题还是如何解决字段的联动关系

## 安装Form

```bash
npm install @form/core
```

## tsconfig

- 由于Form中大量使用装饰器，请将TSConfig中的装饰器能力打开

```json
{
    "compilerOptions": {
        "experimentalDecorators": true
     }
}
```

## 您的第一个表单

```typescript
import { Field } from '@rxform/core';
import { createForm } from "@form/react";

import Form from "./components/From";
import Input from './components/Input';

@Component({
  id: 'email',
  component: 'input',
})
class Email extends Field {}

@Component({
  id: 'nickname',
  component: 'input',
})
class Nickname extends Field {}

@Component({
  id: 'userinfo',
  component: 'form',
  properties: [
    Email,
    Nickname,
  ],
})
class UserInfo extends Field {}

const { form, app } = createForm({
  graph: [
      UserInfo
  ],
  components: {
    form: Form,
    input: Input
  }
});

const root = createRoot(document.getElementById('root')!);
root.render(app);
```

## 社区支持

## Feature

## 决策

- 通过一段布尔表达式，来确定最终的true 和 false，下文均称为"D"
- demo

```typescript
import { D as d } from "form";
const boolValues = {
    isA: true,
    isB: false,
    isC: false
};
const is = d.or('isA','isB').and('isC').evaluate(boolValues); // true
```

### 布尔运算符

- **And**: `D.and('isA','isB') // isA && isB`
- **Or**: `D.or('isA','isB') // isA || isB`
- **Not**: `D.not('isA') // !isA`
- **Use**: `D.use('isA') // isA`

### 自定义运算符

- 创建一个 `n_and`

```typescript
import { registerCustomOperator } from "@form/core";
registerCustomOperator(
  "n_and",
  {
    operator(...bools: boolean[]) {
      return !bools.every(Boolean)
    },
  }
);

D.n_and('isA','isB') // !isA && !isB
```

### 嵌套写法

- 支持链式调用（会将左侧的运算接口，放置后一个操作的第一个参数位置）

```typescript
// isA = true ,isB = false,isC = true
D.and('isA', 'isC')
    .or(
        D.and('isB', 'isC')
       ) // true
```

1. `D.and('isA', 'isC')`: true
2. `D.or(true, D.and('isB', 'isC'))`
3. `D.or(true, false) // true`

### 注册布尔配置

```typescript
type Model = DeepSignal<{
  userinfo: {
    email: string,
    password: number,
    nickname: string,
    residence: string[],
    phone: number,
    donation: number,
  }
}>;

const boolsConfig = {
  isNickname: (model: Model) => model.userinfo.nickname === "cherry",
  // ...
};

const { form, app } = createForm({
  graph: [
      UserInfo
  ],
  boolsConfig, // 布尔运算配置
  components: {
    form: Form,
    input: Input
  },
});
```

### 在成员函数中使用

```typescript
@Component({
  id: 'email',
  component: 'input',
})
class Email extends Field {

    onChange(){
       if( this.evaluateDecision(D.use('isA')) ) { // 或者使用模式匹配
           
       }
    }
}
```

## 模式匹配

- 用于优化流程控制的一种范式
- 配合决策树，可发挥非常强大的流程控制能力，在表单中能发挥强大的关联关系处理能力

```typescript
const value = { type: 'user', name: 'Alice', age: 30 };
const result = match(value, [
      [{ type: 'admin' }, () => 'Matched admin'],
      [{ type: 'user', age: js`value > 18` }, () => 'Matched adult user'],
      [{ type: 'user', age: (age) => age <= 18 }, () => 'Matched minor user'],
      [/^hello/, () => 'Matched pattern starting with hello'],
      [js`value.length > 3`, () => 'Matched string with length > 3'],
      [_, () => 'Default case']
]);

console.log(result); // 'Matched adult user'

const result1 = match(D.and('isA','isB'), [
      [true, () => 'Matched true'],
      [false, () => 'Matched false'],
      [_, () => 'Default case']
]);
console.log(result1); // 'Matched true'

const result1 = match(true, [
      [D.and('isA','isB'), () => 'Matched isA + isB'],
      [D.and('isA','isC'), () => 'Matched isA + isC'],
      [_, () => 'Default case']
]);
console.log(result1); // 'Matched isA + isB'
```

## 基础配置 - Component

- **id**: 表示字段的key
- **component**: 表示字段所渲染的组件，支持字符串或者组件构造器

```typescript
@Component({
  id: 'email',
  component: 'input', // InputComponent
})
class Email extends Field {}
```

- **properties**: 表示字段的子字段，可以是字段的构造函数，亦可为字段的实例

```typescript
@Component({
  id: 'userinfo',
  component: 'form',
  properties: [
    Email,
    new Password(),
    Nickname,
    Residence,
    Phone,
    Donation,
    Intro,
    Gender,
    Captcha,
    Agreement
  ],
})
```

- 在react中，properties传递到字段的组件时，为children，是一个数组

```typescript
import { Form } from "antd";
import React from "react";

export default function (props: any) {
  const { children,style } = props;
  return (
    <Form style={style}>
      {children}
    </Form>
  );
}
```

- 在vue中，properties传递到字段的组件时，为slots，注意，插槽名为其各个子字段的id

```html
<template>
  <div>
    <Form :style="style">
      <template v-for="(, name) in slots" :key="name">
        <slot :name="name"></slot>
      </template>
    </Form>
  </div>
</template>

<script setup lang="ts">
import { Form } from 'ant-design-vue';
import { useSlots } from 'vue';
defineOptions({
  inheritAttrs: false,
});
const slots:Record<string,any> = useSlots();
</script>
```

### Hidden

- **Hidden**：字段隐藏时，会将Value清理为undefined
- **recoverValueOnHidden**：表示，字段隐藏时，其value，不会被清理为undefined
- **recoverValueOnShown**：表示，字段显示时，其value会被回填

```typescript
import { D as d } from "form";

@Component({
  id: 'email',
  component: 'input',
  hidden: d.and('isA','isB').or('isC')
})
class Email extends Field {}
```

### Disabled

```typescript
import { D as d } from "form";

@Component({
  id: 'email',
  component: 'input',
  disabled: d.and('isA','isB').or('isC')
})
class Email extends Field {}
```

## 值行为 - Actions

- **Actions装饰器负责处理字段的输入输出的初始化与回调**

### setDefaultValue

- 此函数的返回值作为字段的初始值

### onSubmitValue

- 此函数的的参数为当前字段的value，返回值为提交时的值

```typescript
@Actions({
  setDefaultValue() {
    // set default value logic
  },

  onSubmitValue(model: any) {
    // submit value logic
  }
})
```

## 校验器 - Validator

- 校验器装饰器，可配置字段的校验模式及其规则

```typescript
@Validator({
  initiative: [
      {
        schema: z.string(),
        updateOn: ['onChange','onInput']
      }
    ],
  singnal: [
      {
           fact: {
               value: "$value",
               email: "$.userinfo.email"
           },
           schema: z.object({
               value: z.string(),
               email: z.string().email({ message: "E-mail is not a valid email address" }),
           })
      }
  ]
})
```

### initiative

- 此属性可配置具体的事件触发时的校验规则
- 其ts类型

```typescript
export interface ValidateItem {
  schema: any;
  engine?: string;
  fact?: string | object;
  updateOn?: string | string[];
  needValidate?: Decision;
  factoryOptions?: FactoryOptions;
  schemaOptions?: any;
}

type Initiative = ValidateItem[];
```

#### schema

- 表示当前校验器采用什么校验函数

#### engine

- 表示当前校验器采用什么校验引擎

#### fact

- 表示校验器对什么形状的数据进行校验，多用于signal模式中
- 在initiative中，直接为value，在signal模式中，可为对象，此对象也就是当前校验器的依赖项
- `$` 表示，表单model，`$value` 表示当前字段的value

```typescript
{
   fact: {
       value: "$value",
       email: "$.userinfo.email"
   }
}
```

#### needValidate

- 表示当前校验是否需要校验，value为D

```typescript
{
   needValidate: D.and('isA','isB')
}
```

#### factoryOptions

- 作为校验引擎的参数

#### schemaOptions

- 作为校验引擎的参数

### signal

- 此属性可配置字段被动校验的规则
- 其余与initiative一致

### 自定义校验引擎

```typescript
import { zodResolver } from "@rxform/resolvers"; // official engine

// 参数为 上述ValidateItem中的 schema, schemaOptions, resolverOptions
const customResolver = (schema, schemaOptions, resolverOptions = {}) =>{

    return {
        errors: {},
        values
    }
}

const { form, app } = createForm({
  graph: [
      UserInfo
  ],
  resolvers: {
    validator: {
      zod: zodResolver,
      custom: customResolver
    }
  },
  components: {
    form: Form,
    input: Input
  },
});
```

## 注入字段 - InjectFields

- 此装饰器表达当前字段所依赖哪些字段状态,可将这些字段的value注入在此字段中
- 是一个对象，其key，可自定义，value为依赖字段的路径
- 配合Fields装饰器消费

```typescript
@InjectFields({
  gender: "userinfo.gender",
  donation: "userinfo.donation"
})
```

## 消费字段 - Fields

- 此装饰器可用于消费InjectFields装饰器所注入的字段
- 当消费的字段其value被修改时，会自动触发所修饰的函数
- 当订阅高位的字段修改时，此函数会等待高位字段间接所影响影响更新完毕才会执行
  - eg：当A修改时，C字段的更新，会等待A，B字段都完成时，才会执行

```typescript
@Fields({
    gender: "gender",
    donation: "donation"
 }) // 会等待 gender + donation 都完成状态处理后才会执行
onGenderValue(fields: Record<string, any>) {
    console.log("onGenderValue", fields);
}
```

## 组件属性 - Props

- **Prop装饰器，此装饰器不仅能修饰此属性为字段的组件props，也能使其具有响应化（signal）**

```typescript
@Component({
  id: "nickname",
  component: "input",
})
class Nickname extends Field {
  @Prop()
  title = "Nickname";
}
```

## 组件事件 - Event

- **Event装饰器，此装饰器能修饰此函数为字段组件的事件**

```typescript
@Component({
  id: "nickname",
  component: "input",
})
class Nickname extends Field {
  @Prop()
  title = "Nickname";
  
  @Event()
  onChange(data: string){
    this.value = data;
  }
}
```

## 祖孙字段通信 - 依赖注入

- 仅适用被provide的后代才能使用

### 提供方 - Provide

```typescript
@Component({
  id: "useinfo",
  component: "form",
  properties: [
      Gender
  ]
})
class UseInfo extends Field {
  @Provide("optionList") // 当key 和提供的属性的key一致时，可以不用写
  options = [
    {
      value: "male",
      label: "Male"
    },
    {
      value: "female",
      label: "Female"
    },
    {
      value: "other",
      label: "Other"
    }
  ];
}
```

### 消费方 - Inject

```typescript
@Component({
  id: "gender",
  component: "select",
})
class Gender extends Field {
  @Inject("optionList") // 当key 和提供的属性的key一致时，可以不用写
  options = [];
}
```

### 无关系字段通信 - 发布订阅

#### 发布 - DispatchData

- 装饰器参数：第一个参数为发布的key，第二参数为，初始化时，是否主动派发一次
- 当 genderData被修改时，即刻派发

```typescript
@Component({
  id: "gender",
  component: "select",
})
class Gender extends Field {
  @DispatchData("gender", false)
  genderData = "";
}
```

#### 订阅 - SubscribeData

- 装饰器参数：第一个参数为订阅的key

```typescript
@Component({
  id: "name",
  component: "input",
})
class Gender extends Field {
  @SubscribeData("gender")
  genderData = "";
}
```

### Emitter

```typescript
@Component({
  id: "name",
  component: "input",
})
class Gender extends Field {

    onChange(){
        this.emitter.emit('key','value');
    }
}
```

## 数据监听

### Watch

- 用于声明在数据更改时调用的侦听回调。

### WatchEffect

- 立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。

```typescript
@Component({
  id: "gender",
  component: "select",
})
class Gender extends Field {
  @Prop()
  title = "Gender";

  @Prop()
  options = [
    {
      value: "male",
      label: "Male"
    },
    {
      value: "female",
      label: "Female"
    },
    {
      value: "other",
      label: "Other"
    }
  ];

  @Watch("options")
  onOptionsChange(options, oldValue) {
    console.log("onOptionsChange", options);
  }

  @Watch(["options", "title"])
  onStateChange([options, title], oldValue) {
    console.log("onStateChange", title, options);
  }

  @WatchEffect // 自动搜集依赖项
  onOptionsChanges() {
    console.log("onOptionsChanges", this.options);
  }
}
```

## 响应式属性 - Signal

```typescript
@Component({
  id: "gender",
  component: "select",
})
class Gender extends Field {
  // 原始数据，不具有响应式
  jsData = {
    a: 1,
    b: 2
  };

  @Signal // 响应式数据, 类似 reactiveData = deepSignal({  a: 1, b: 2 })
  reactiveData = {
    a: 1,
    b: 2
  };
}
```

## 有条件的函数 - Condition

- 装饰工厂的参数为 决策树，当决策为true时，会自动触发所装饰的函数

```typescript
@Component({
  id: "gender",
  component: "select",
})
class Gender extends Field {

  @Condition(D.use('isNickname'))
  setOptions() {
    // logic for setting options
  }
}
```
